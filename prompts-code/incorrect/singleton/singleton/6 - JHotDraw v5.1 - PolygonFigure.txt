Given the following java code, determine whether it contains an instance of the singleton design pattern playing the role of singleton.

You should read the entire code snippet carefully. Then answer with YES or NO in capital letters. Finally, In 2-3 short sentences, explain why that is the answer

CODE:


package CH.ifa.draw.contrib;

import java.awt.Graphics;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Vector;

import CH.ifa.draw.figures.AttributeFigure;
import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.standard.AbstractLocator;
import CH.ifa.draw.util.Geom;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;


public  class PolygonFigure extends AttributeFigure {

  
  static final int TOO_CLOSE = 2;

  
  private static final long serialVersionUID = 6254089689239215026L;
  private int polygonFigureSerializedDataVersion = 1;

  protected Polygon fPoly = new Polygon();

  public PolygonFigure() {
	super();
  }  

  public PolygonFigure(int x, int y) {
	fPoly.addPoint(x, y);
  }  

  public PolygonFigure(Polygon p) {
	fPoly = new Polygon(p.xpoints, p.ypoints, p.npoints);
  }  

  public Rectangle displayBox() {
	return bounds(fPoly);
  }  


  public boolean isEmpty() {
	return (fPoly.npoints < 3 ||
			(size().width < TOO_CLOSE) && (size().height < TOO_CLOSE));
  }  

  public Vector handles() {
	Vector handles = new Vector(fPoly.npoints);
	for (int i = 0; i < fPoly.npoints; i++)
	  handles.addElement(new PolygonHandle(this, locator(i), i));
	handles.addElement(new PolygonScaleHandle(this));
	
	return handles;
  }  


  public void basicDisplayBox(Point origin, Point corner) {
	Rectangle r = displayBox();
	int dx = origin.x - r.x;
	int dy = origin.y - r.y;
	fPoly.translate(dx, dy);
	r = displayBox();
	Point oldCorner = new Point(r.x + r.width, r.y + r.height);
	Polygon p = getPolygon();
	scaleRotate(oldCorner, p, corner);
  }  

  
  public Polygon getPolygon() {
	return new Polygon(fPoly.xpoints, fPoly.ypoints, fPoly.npoints);
  }  

  public Point center() {
	return center(fPoly);
  }  

  public Enumeration points() {
	Vector pts = new Vector(fPoly.npoints);
	for (int i = 0; i < fPoly.npoints; ++i)
	  pts.addElement(new Point(fPoly.xpoints[i], fPoly.ypoints[i]));
	return pts.elements();
  }  

  public int pointCount() {
	return fPoly.npoints;
  }  

  public void basicMoveBy(int dx, int dy) {
	fPoly.translate(dx, dy);
  }  

  public void drawBackground(Graphics g) {
	  g.fillPolygon(fPoly);
  }  

  public void drawFrame(Graphics g) {
	  g.drawPolygon(fPoly);
  }  

  public boolean containsPoint(int x, int y) {
	return fPoly.contains(x, y);
  }  

  public Connector connectorAt(int x, int y) {
	return new ChopPolygonConnector(this);
  }  

  
  public  void addPoint(int x, int y) {
	fPoly.addPoint(x, y);
	changed();
  }  


  
  public  void setPointAt(Point p, int i) {
	willChange();
	fPoly.xpoints[i] = p.x;
	fPoly.ypoints[i] = p.y;
	changed();
  }  

  
  public  void insertPointAt(Point p, int i) {
	willChange();
	int n = fPoly.npoints + 1;
	int[] xs = new int[n];
	int[] ys = new int[n];
	for (int j = 0; j < i; ++j) {
	  xs[j] = fPoly.xpoints[j];
	  ys[j] = fPoly.ypoints[j];
	}
	xs[i] = p.x;
	ys[i] = p.y;
	for (int j = i; j < fPoly.npoints; ++j) {
	  xs[j+1] = fPoly.xpoints[j];
	  ys[j+1] = fPoly.ypoints[j];
	}

	fPoly = new Polygon(xs, ys, n);
	changed();
  }  

  public  void removePointAt(int i) {
	willChange();
	int n = fPoly.npoints - 1;
	int[] xs = new int[n];
	int[] ys = new int[n];
	for (int j = 0; j < i; ++j) {
	  xs[j] = fPoly.xpoints[j];
	  ys[j] = fPoly.ypoints[j];
	}
	for (int j = i; j < n; ++j) {
	  xs[j] = fPoly.xpoints[j+1];
	  ys[j] = fPoly.ypoints[j+1];
	}
	fPoly = new Polygon(xs, ys, n);
	changed();
  }  

  
  public  void scaleRotate(Point anchor, Polygon originalPolygon, Point p) {
	willChange();

	
	Point ctr = center(originalPolygon);
	double anchorLen = Geom.length(ctr.x, ctr.y, anchor.x, anchor.y);

	if (anchorLen > 0.0) {
	  double newLen = Geom.length(ctr.x, ctr.y, p.x, p.y);
	  double ratio = newLen / anchorLen;

	  double anchorAngle = Math.atan2(anchor.y - ctr.y, anchor.x - ctr.x);
	  double newAngle = Math.atan2(p.y - ctr.y, p.x - ctr.x);
	  double rotation = newAngle - anchorAngle;

	  int n = originalPolygon.npoints;
	  int[] xs = new int[n];
	  int[] ys = new int[n];

	  for (int i = 0; i < n; ++i) {
		int x = originalPolygon.xpoints[i];
		int y = originalPolygon.ypoints[i];
		double l = Geom.length(ctr.x, ctr.y, x, y) * ratio;
		double a = Math.atan2(y - ctr.y, x - ctr.x) + rotation;
		xs[i] = (int)(ctr.x + l * Math.cos(a) + 0.5);
		ys[i] = (int)(ctr.y + l * Math.sin(a) + 0.5);
	  }
	  fPoly =  new Polygon(xs, ys, n);
	}
	changed();
  }  


  
  public void smoothPoints() {
	willChange();
	boolean removed = false;
	int n = fPoly.npoints;
	do {
	  removed = false;
	  int i = 0;
	  while (i < n && n >= 3) {
		int nxt = (i + 1) % n;
		int prv = (i - 1 + n) % n;

		if ((distanceFromLine(fPoly.xpoints[prv], fPoly.ypoints[prv],
							  fPoly.xpoints[nxt], fPoly.ypoints[nxt],
							  fPoly.xpoints[i], fPoly.ypoints[i]) < TOO_CLOSE)) {
		  removed = true;
		  --n;
		  for (int j = i; j < n; ++j) {
			fPoly.xpoints[j] = fPoly.xpoints[j+1];
			fPoly.ypoints[j] = fPoly.ypoints[j+1];
		  }
		}
		else
		  ++i;
	  }
	} while(removed);
	if (n != fPoly.npoints)
	  fPoly =  new Polygon(fPoly.xpoints, fPoly.ypoints, n);
	changed();
  }  

  
  public int splitSegment(int x, int y) {
	int i = findSegment(x, y);
	if (i != -1) {
	  insertPointAt(new Point(x, y), i+1);
	  return i + 1;
	}
	else
	  return -1;
  }  

  public Point pointAt(int i) {
	return new Point(fPoly.xpoints[i], fPoly.ypoints[i]);
  }  

  
  public Point outermostPoint() {
	Point ctr = center();
	int outer = 0;
	long dist = 0;

	for (int i = 0; i < fPoly.npoints; ++i) {
	  long d = Geom.length2(ctr.x, ctr.y, fPoly.xpoints[i], fPoly.ypoints[i]);
	  if (d > dist) {
		dist = d;
		outer = i;
	  }
	}

	return new Point(fPoly.xpoints[outer], fPoly.ypoints[outer]);
  }  


  
  public int findSegment(int x, int y) {
	double dist = TOO_CLOSE;
	int best = -1;

	for (int i = 0; i < fPoly.npoints; i++) {
	  int n = (i + 1) % fPoly.npoints;
	  double d =  distanceFromLine(fPoly.xpoints[i], fPoly.ypoints[i],
								   fPoly.xpoints[n], fPoly.ypoints[n],
								   x, y);
	  if (d < dist) {
		dist = d;
		best = i;
	  }
	}
	return best;
  }  

  public Point chop(Point p) {
	return chop(fPoly, p);
  }  

  public void write(StorableOutput dw) {
	super.write(dw);
	dw.writeInt(fPoly.npoints);
	for (int i = 0; i < fPoly.npoints; ++i) {
	  dw.writeInt(fPoly.xpoints[i]);
	  dw.writeInt(fPoly.ypoints[i]);
	}
  }  

  public void read(StorableInput dr) throws IOException {
	super.read(dr);
	int size = dr.readInt();
	int[] xs = new int[size];
	int[] ys = new int[size];
	for (int i = 0; i < size; i++) {
	  xs[i] = dr.readInt();
	  ys[i] = dr.readInt();
	}
	fPoly = new Polygon(xs, ys, size);
  }  

  
  public static Locator locator(final int pointIndex) {
	return new AbstractLocator() {
	  public Point locate(Figure owner) {
		PolygonFigure plf = (PolygonFigure)owner;
		
		if (pointIndex < plf.pointCount())
		  return ((PolygonFigure)owner).pointAt(pointIndex);
		return new Point(-1, -1);
	  }
	};
  }  

  
  public static double distanceFromLine(int xa, int ya,
										int xb, int yb,
										int xc, int yc) {


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	int xdiff = xb - xa;
	int ydiff = yb - ya;
	long l2 = xdiff*xdiff + ydiff*ydiff;

	if (l2 == 0) return Geom.length(xa, ya, xc, yc);

	double rnum =  (ya-yc) * (ya-yb) - (xa-xc) * (xb-xa);
	double r = rnum / l2;

	if (r < 0.0 || r > 1.0) return Double.MAX_VALUE;

	double xi = xa + r * xdiff;
	double yi = ya + r * ydiff;
	double xd = xc - xi;
	double yd = yc - yi;
	return Math.sqrt(xd * xd + yd * yd);

	
  }  

  

  public static Rectangle bounds(Polygon p) {
	int minx = Integer.MAX_VALUE;
	int miny = Integer.MAX_VALUE;
	int maxx = Integer.MIN_VALUE;
	int maxy = Integer.MIN_VALUE;
	int n = p.npoints;
	for (int i = 0; i < n; i++) {
	  int x = p.xpoints[i];
	  int y = p.ypoints[i];
	  if (x > maxx) maxx = x;
	  if (x < minx) minx = x;
	  if (y > maxy) maxy = y;
	  if (y < miny) miny = y;
	}

	return new Rectangle(minx, miny, maxx-minx, maxy-miny);
  }  

  public static Point center(Polygon p) {
	long sx = 0;
	long sy = 0;
	int n = p.npoints;
	for (int i = 0; i < n; i++) {
	  sx += p.xpoints[i];
	  sy += p.ypoints[i];
	}

	return new Point((int)(sx/n), (int)(sy/n));
  }  

  public static Point chop(Polygon poly, Point p) {
	Point ctr = center(poly);
	int cx = -1;
	int cy = -1;
	long len = Long.MAX_VALUE;

	

	for (int i = 0; i < poly.npoints; ++i) {
	  int nxt = (i + 1) % poly.npoints;
	  Point chop = Geom.intersect(poly.xpoints[i],
							 poly.ypoints[i],
							 poly.xpoints[nxt],
							 poly.ypoints[nxt],
							 p.x,
							 p.y,
							 ctr.x,
							 ctr.y);
	  if (chop != null) {
		long cl = Geom.length2(chop.x, chop.y, p.x, p.y);
		if (cl < len) {
		  len = cl;
		  cx = chop.x;
		  cy = chop.y;
		}
	  }
	}
	
	
	{ 
	  for (int i = 0; i < poly.npoints; ++i) {
		long l = Geom.length2(poly.xpoints[i], poly.ypoints[i], p.x, p.y);
		if (l < len) {
		  len = l;
		  cx = poly.xpoints[i];
		  cy = poly.ypoints[i];
		}
	  }
	}
	return new Point(cx, cy);
  }  

}

