Given the following java code, determine whether it contains an instance of the adapter design pattern playing the role of adapter.

You should read the entire code snippet carefully. Then answer with YES or NO in capital letters. Finally, In 2-3 short sentences, explain why that is the answer

CODE:


package org.netbeans.core;

import java.io.*;
import java.beans.*;
import java.util.*;

import org.openide.ServiceType;
import org.openide.modules.ManifestSection;
import org.openide.nodes.*;
import org.openide.util.enum.*;
import org.openide.util.Mutex;
import org.openide.util.io.NbMarshalledObject;

import org.netbeans.beaninfo.editors.ExecutorEditor;
import org.netbeans.beaninfo.editors.CompilerTypeEditor;
import org.netbeans.beaninfo.editors.DebuggerTypeEditor;


final class Services extends ServiceType.Registry {
    
    static final long serialVersionUID =-7558069607307508327L;

    
    private static final Services INSTANCE = new Services ();

    
    public static final SubLevel FIRST = new SubLevel ();

    
    private static List current;

    
    public static Services getDefault () {
        return INSTANCE;
    }

    
    public ServiceType find (Class clazz) {
        if (clazz == ExecutorEditor.NoExecutor.class)
            return ExecutorEditor.NO_EXECUTOR;
        else if (clazz == CompilerTypeEditor.NoCompiler.class)
            return CompilerTypeEditor.NO_COMPILER;
        else if (clazz == DebuggerTypeEditor.NoDebugger.class)
            return DebuggerTypeEditor.NO_DEBUGGER;
        else
            return super.find (clazz);
    }

    
    public ServiceType find (String name) {
        if (name.equals (ExecutorEditor.NO_EXECUTOR.getName ()))
            return ExecutorEditor.NO_EXECUTOR;
        else if (name.equals (CompilerTypeEditor.NO_COMPILER.getName ()))
            return CompilerTypeEditor.NO_COMPILER;
        else if (name.equals (DebuggerTypeEditor.NO_DEBUGGER.getName ()))
            return DebuggerTypeEditor.NO_DEBUGGER;
        else
            return super.find (name);
    }

    
    public static void addService (final ManifestSection.ServiceSection s)
    throws InstantiationException {
        try {
            Children.MUTEX.writeAccess (new Mutex.ExceptionAction () {
                                            public Object run () throws InstantiationException {
                                                FIRST.add (s);
                                                return null;
                                            }
                                        });
        } catch (org.openide.util.MutexException ex) {
            throw (InstantiationException)ex.getException ();
        }
    }

    
    public static void removeService (final ManifestSection.ServiceSection s)
    throws InstantiationException {
        try {
            Children.MUTEX.writeAccess (new Mutex.ExceptionAction () {
                                            public Object run () throws InstantiationException {
                                                FIRST.remove (s);
                                                return null;
                                            }
                                        });
        } catch (org.openide.util.MutexException ex) {
            throw (InstantiationException)ex.getException ();
        }
    }

    
    static void firePropertyChange () {
        current = null;
    }

    
    static boolean debug () {
        return System.getProperty ("netbeans.debug.exceptions") != null;
    }

    
    private java.util.List getServiceTypesImpl () {
        List l = current;
        if (l == null) {
            l = (List)Children.MUTEX.readAccess (new Mutex.Action () {
                                                     public Object run () {
                                                         LinkedList ll = new LinkedList ();
                                                         Enumeration en = FIRST.services ();
                                                         while (en.hasMoreElements ()) {
                                                             ll.add (en.nextElement ());
                                                         }
                                                         return ll;
                                                     }
                                                 });
            current = l;
        }
        return l;
    }

    
    public java.util.List getServiceTypes () {
        return new LinkedList (getServiceTypesImpl ());
    }

    
    private void setServiceTypesImpl (final java.util.List arr) {
        Children.MUTEX.postWriteRequest (new Runnable () {
                                             public void run () {
                                                 current = null;
                                                 FIRST.changeAll (arr);
                                                 firePropertyChange ();
                                             }
                                         });
    }

    
    public void setServiceTypes (java.util.List arr) {
        setServiceTypesImpl (new LinkedList (arr));
    }

    
    public Enumeration services () {
        return Collections.enumeration (getServiceTypesImpl ());
    }




    
    private void writeObject (ObjectOutputStream oos) throws IOException {
        Enumeration en = services ();
        while (en.hasMoreElements ()) {
            ServiceType s = (ServiceType)en.nextElement ();

            NbMarshalledObject obj;
            try {
                obj = new NbMarshalledObject (s);
            } catch (IOException ex) {
                if (debug ()) ex.printStackTrace();
                
                obj = null;
            }
            if (obj != null) {
                oos.writeObject (obj);
            }
        }

        oos.writeObject (null);
    }

    
    private void readObject (ObjectInputStream oos)
    throws IOException, ClassNotFoundException {
        final LinkedList ll = new LinkedList ();
        for (;;) {
            NbMarshalledObject obj = (NbMarshalledObject)oos.readObject ();

            if (obj == null) {
                break;
            }

            try {
                ServiceType s = (ServiceType)obj.get ();
                ll.add (s);
            } catch (IOException ex) {
                if (debug ()) ex.printStackTrace();
            } catch (ClassNotFoundException ex) {
                if (debug ()) ex.printStackTrace();
            }
        }

        setServiceTypesImpl (ll);
    }

    
    private Object readResolve () {
        return INSTANCE;
    }

    
    static interface Level {
        
        public void add (ManifestSection.ServiceSection section)
        throws InstantiationException;

        
        public boolean remove (ManifestSection.ServiceSection section)
        throws InstantiationException;

        
        public Enumeration services ();


        
        public void changeAll (Collection c);
    }

    
    static abstract class SectionChildren extends Index.ArrayChildren
        implements Level {
        
        private java.util.Map map;

        
        protected java.util.Collection initCollection () {
            return new LinkedList ();
        }

        
        public final void add (ManifestSection.ServiceSection section)
        throws InstantiationException {

            Object key = key (section.getServiceType());

            if (map == null) {
                map = new HashMap (11);
            }

            if (nodes == null) {
                nodes = initCollection ();
            }

            Node subNode = (Node)map.get (key);
            if (subNode == null) {
                subNode = createChildren (section);
                map.put (key, subNode);

                
                if (section.isDefault ()) {
                    ((LinkedList)nodes).addFirst (subNode);
                } else {
                    nodes.add (subNode);
                }
                refresh ();
            }

            Level l = (Level)subNode.getChildren ();
            l.add (section);
        }

        
        public final boolean remove (ManifestSection.ServiceSection section)
        throws InstantiationException {

            Object key = key (section.getServiceType());

            Node subNode = (Node)map.get (key);
            Level l = (Level)subNode.getChildren ();
            if (l.remove (section)) {
                map.remove (key);
                nodes.remove (subNode);
                refresh ();
            }

            return getNodesCount () == 0;
        }

        
        public void reorder (int[] perm) {
            super.reorder (perm);
            firePropertyChange ();
        }

        
        public final Enumeration services () {
            Enumeration en = nodes ();

            
            AlterEnumeration aen = new AlterEnumeration (en) {
                                       public Object alter (Object o) {
                                           Node n = (Node)o;
                                           return ((Level)n.getChildren ()).services ();
                                       }
                                   };

            
            return new SequenceEnumeration (aen);
        }

        
        public void changeAll (Collection c) {
            java.util.Map unusedEntries = (java.util.Map) ((java.util.HashMap) map).clone();
            Iterator it = c.iterator ();
            LinkedList newKeys = new LinkedList ();
            while (it.hasNext ()) {
                ServiceType s = (ServiceType)it.next ();
                
                try {
                    Object key = key(s);
                    Node n = (Node)map.get(key);
                    if (n != null && !newKeys.contains (n)) {
                        newKeys.add (n);
                        unusedEntries.remove(key);
                    }
                } catch (InstantiationException e) {
                }
            }

            
            HashSet ignore = new HashSet();
            it = unusedEntries.entrySet().iterator();
            if (it.hasNext()) {
                while (it.hasNext()) {
                    java.util.Map.Entry entry = (java.util.Map.Entry) it.next();
                    Class clz = (Class) entry.getKey();

                    if (this.getClass () != TypeLevel.class) {
                        map.remove(entry.getKey());
                        nodes.remove((Node) entry.getValue());
                    } else if (clz.getName().indexOf("FastJavacCompilerType") >= 0) { 
                        ignore.add(entry.getValue());
                    }
                }
            }

            
            
            refresh ();

            
            Node[] current = getNodes ();
            int[] perm = new int[current.length];

            int max = newKeys.size();

            for (int i = 0; i < current.length; i++) {
                int indx = newKeys.indexOf (current[i]);
                if (indx == -1) {
                    
                    perm[i] = max++;
                } else {
                    
                    perm[i] = indx;
                }
            }

            Enumeration en = nodes ();
            while (en.hasMoreElements ()) {
                Node n = (Node)en.nextElement ();
                Level l = (Level)n.getChildren ();
                if (ignore.contains(n)) {
                    l.changeAll(Collections.EMPTY_LIST);
                } else {
                    l.changeAll (c);
                }
            }

            
            super.reorder (perm);

        }

        
        protected abstract Object key (ServiceType service)
        throws InstantiationException;


        
        protected abstract Node createChildren (ManifestSection.ServiceSection section)
        throws InstantiationException;
    }

    
    static final class SubLevel extends SectionChildren {
        
        protected Object key (ServiceType section)
        throws InstantiationException {
            return findClass (section);
        }


        
        protected Node createChildren (ManifestSection.ServiceSection section)
        throws InstantiationException {
            AbstractNode an = new ServicesNode.SubLevel (
                                  findClass (section.getServiceType ())
                              );
            return an;
        }

        
        private static Class findClass (ServiceType s)
        throws InstantiationException {
            Class c = s.getClass ();
            for (;;) {
                Class ss = c.getSuperclass ();
                if (ss == ServiceType.class) {
                    return c;
                }
                c = ss;
            }
        }
    }

    
    static final class TypeLevel extends SectionChildren {
        
        protected Object key (ServiceType section)
        throws InstantiationException {
            return section.getClass ();
        }


        
        protected Node createChildren (ManifestSection.ServiceSection section)
        throws InstantiationException {
            AbstractNode an = new ServicesNode.TypeLevel (
                                  section.getServiceType ().getClass ()
                              );
            return an;
        }

    }

    
    static final class InstanceLevel extends Children.Keys
        implements Level {
        
        private ManifestSection.ServiceSection section;
        
        private List all;
        
        private ServiceType def;

        public InstanceLevel () {
            setBefore (true);
            all = new LinkedList ();
            def = null;
        }

        
        protected Node[] createNodes (Object key) {
            try {
                return new Node[] {
                           new ServicesNode.InstanceLevel ((ServiceType)key)
                       };
            } catch (IntrospectionException ex) {
                if (debug ()) ex.printStackTrace();
                return new Node[0];
            }
        }

        
        public void add(ManifestSection.ServiceSection section)
        throws InstantiationException {

            ServiceType s = section.getServiceType ();

            
            if (section.isDefault () || this.section == null) {
                this.section = section;
                def = s;
            }


            

            try {
                add (s);
            } catch (Exception ex) {
                if (debug ()) ex.printStackTrace();
                return;
            }

            if (section.isDefault () && def != null) {
                refreshKey (def);
            }
        }

        
        public boolean remove(ManifestSection.ServiceSection section)
        throws InstantiationException {
            ServiceType s = section.getServiceType ();

            destroy (s);

            if (def == null) {
                return true;
            }

            refreshKey (def);
            return false;
        }

        
        public Enumeration services() {
            return Collections.enumeration (all);
        }

        
        
        

        
        void create () throws Exception {
            add (uniquify (section.createServiceType ()));
        }

        
        private static boolean containsName (String name) {
            Enumeration e = INSTANCE.services ();
            while (e.hasMoreElements ()) {
                ServiceType s = (ServiceType) e.nextElement ();
                if (s.getName ().equals (name)) return true;
            }
            return false;
        }

        
        static ServiceType uniquify (ServiceType type) throws IOException, ClassNotFoundException {
            if (containsName (type.getName ())) {
                type = (ServiceType) new NbMarshalledObject (type).get ();
                String name = type.getName ();
                int suffix = 2;
                String newname;
                while (containsName (newname = Main.getString ("LBL_ServiceType_Duplicate", name, String.valueOf (suffix)))) suffix++;
                type.setName (newname);
            }
            return type;
        }

        
        public void add (ServiceType s) throws Exception {
            if (all.contains (s)) {
                NbMarshalledObject m = new NbMarshalledObject (s);
                s = (ServiceType)m.get ();
            }
            if (all == Collections.EMPTY_LIST) {
                throw new RuntimeException(Main.getString("EXC_Forbidden_New"));
            }
            all.add (s);
            def = (ServiceType) all.get (0);
            setKeys (all);

            firePropertyChange ();
        }

        
        public void destroy (ServiceType s) {
            all.remove (s);
            def = all.isEmpty () ? null : (ServiceType) all.get (0);
            setKeys (all);

            firePropertyChange ();
        }

        
        public void changeAll (Collection c) {
            Class cl;
            try {
                cl = section.getServiceType ().getClass ();
            } catch (InstantiationException ex) {
                if (debug ()) ex.printStackTrace();
                return;
            }

            List ll = new LinkedList ();
            Iterator it = c.iterator ();
            while (it.hasNext ()) {
                ServiceType s = (ServiceType) it.next ();
                
                if (s.getClass () != cl) continue;

                
                it.remove ();
                ll.add (s);
            }

            
            if (!ll.isEmpty ()) {
                
                def = (ServiceType) ll.get (0);
                setKeys (all = ll);

                it = all.iterator ();
                while (it.hasNext ()) refreshKey (it.next ());

                firePropertyChange ();
            }
            
            
            if (c == Collections.EMPTY_LIST) {
                setKeys(all = Collections.EMPTY_LIST);
                firePropertyChange ();                
            }
        }

        
        public Index getIndex () {
            return new Index.Support () {
                       public Node[] getNodes () {
                           return InstanceLevel.this.getNodes ();
                       }
                       public int getNodesCount () {
                           return getNodes ().length;
                       }
                       public void reorder (int[] perm) {
                           ServiceType[] nue = new ServiceType[perm.length];
                           for (int i = 0; i < perm.length; i++)
                               nue[i] = ((ServicesNode.InstanceLevel) getNodes () [perm[i]]).getService ();
                           changeAll (new ArrayList (Arrays.asList (nue)));
                       }
                   };
        }

    }
}

