Given the following java code, determine whether it contains an instance of the composite design pattern playing the role of leaf.

You should read the entire code snippet carefully. Then answer with YES or NO in capital letters. Finally, In 2-3 short sentences, explain why that is the answer

CODE:


package diagram.tool;

import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.SwingUtilities;
import javax.swing.event.MouseInputAdapter;

import diagram.Diagram;
import diagram.DiagramUI;
import diagram.Figure;
import diagram.Link;
import diagram.figures.FigureBorder;



public class FigureShappingTool extends AbstractTool {

  
  private static final Cursor HZ_CURSOR = new Cursor(Cursor.W_RESIZE_CURSOR);
  private static final Cursor VT_CURSOR = new Cursor(Cursor.N_RESIZE_CURSOR);
  private static final Cursor SENW_CURSOR = new Cursor(Cursor.NW_RESIZE_CURSOR);
  private static final Cursor SWNE_CURSOR = new Cursor(Cursor.SW_RESIZE_CURSOR);

  
  private static final int QUAD_LEFT   = 0x01;
  private static final int QUAD_MIDDLE = 0x02;
  private static final int QUAD_RIGHT  = 0x04;
  private static final int QUAD_TOP    = 0x100;
  private static final int QUAD_CENTER = 0x200;
  private static final int QUAD_BOTTOM = 0x400;

  
  private static final int MINIMUM_SIZE = 0x10;

  private MouseHandler mouseHandler = new MouseHandler();

  
  private Graphics2D graphics;
  
  
  private Point2D dragPoint;
  private Point2D lastPoint;

  private Rectangle2D.Double outline = new Rectangle2D.Double();
  private Cursor originalCursor = null;
  private Diagram diagram;

  
  private Point2D center;
  private Rectangle2D bounds;
  private Figure figure = null;
  protected Figure[] relatedFigures = new Figure[4];

  private int sizingDirection = -1;


  
  public void install(Diagram diagram) {
    diagram.addMouseListener(mouseHandler);
    diagram.addMouseMotionListener(mouseHandler);
  }
  
  
  public void uninstall(Diagram diagram) {

    diagram.removeMouseListener(mouseHandler);
    diagram.removeMouseMotionListener(mouseHandler);

    reset();

  }

  
  
  protected class MouseHandler extends MouseInputAdapter {

    
    public void mousePressed(MouseEvent e) {
      
      
      if(e.isConsumed() || !SwingUtilities.isLeftMouseButton(e))
        return;
      
      diagram = (Diagram)e.getSource();
      Point2D pt = e.getPoint();
      
      
      
      figure = (Figure)diagram.findFigure(pt);
      
      if(figure == null || (figure instanceof Link)) {
        reset();
        return;
      }
      
      
      
      bounds  = figure.getBounds2D(bounds);
      center = figure.getCenter(center);
      
      
      if(!FigureBorder.isBorderPoint(figure, pt)) {
        reset();
        return;
      }

      e.consume();
      fireToolStarted();

      
      outline.setFrame(bounds);
      
      dragPoint = pt;
      getQuadrant(dragPoint);

      
      originalCursor = diagram.getCursor();
      diagram.setCursor(getCursor());
    
      
      graphics = getGraphics(diagram);
      
      
      DiagramUI ui = (DiagramUI)diagram.getUI();
      relatedFigures = ui.getConnected(figure, relatedFigures);

    } 


    
    public void mouseDragged(MouseEvent e) {

      
      if(dragPoint == null) 
        return;

      Point2D pt = e.getPoint();

      double dx = pt.getX() - dragPoint.getX();
      double dy = pt.getY() - dragPoint.getY();

      paintOutline(dx, dy, false);

      lastPoint = pt;

    }

    
    public void mouseReleased(MouseEvent e) {

      if(dragPoint != null) {
      
        if(lastPoint != null) { 

          
          paintOutline(0, 0, true);
        
          
          figure.setBounds(outline.getX(), outline.getY(), 
                           outline.getWidth(), outline.getHeight());

        }

        
        DiagramUI ui = (DiagramUI)diagram.getUI();
        Figure[] related = relatedFigures;

        for(int j=0; j < related.length && related[j] != null; j++)
          ui.damageFigure(related[j]);

        
        ((DiagramUI)diagram.getUI()).refreshFigure(figure);
        reset();

        fireToolFinished();

      }
    
    }

  }

  
  private final void paintOutline(double dx, double dy, boolean eraseOnly) {

     
    if(lastPoint != null)
      graphics.drawRect((int)outline.x, (int)outline.y, (int)outline.width, (int)outline.height);

    
    if(!eraseOnly && !(dx == 0 && dy == 0)) {

      reshapeOutline(dx, dy);
      graphics.drawRect((int)outline.x, (int)outline.y, (int)outline.width, (int)outline.height);

    }

    ((DiagramUI)diagram.getUI()).damageFigure(figure);
    
  }

  
  private final void reshapeOutline(double dx, double dy) {

    int min = MINIMUM_SIZE;
    double t;

    if(hasQuad(QUAD_LEFT)) {
      
      if((t = bounds.getWidth() - dx) > min) {
        outline.x = bounds.getX() + dx;
        outline.width = t;
      }

    } else if(hasQuad(QUAD_RIGHT))

      if((t = bounds.getWidth() + dx) > min)
        outline.width = t;

    if(hasQuad(QUAD_TOP)) {

      if((t = bounds.getHeight() - dy) > min) {
        outline.y = bounds.getY() + dy;
        outline.height = t;
      }

    } else if(hasQuad(QUAD_BOTTOM))

      if((t = bounds.getHeight() + dy) > min)
        outline.height = t;

  }

  
  private final void getQuadrant(Point2D pt) {

    double padx = bounds.getWidth() / 8d;
    double pady = bounds.getHeight() / 8d;

    double x = pt.getX();
    double y = pt.getY();
    
    double centerX = center.getX();
    double centerY = center.getY();

    int dir;

    if(x < centerX - padx) 
      dir = QUAD_LEFT;
    else if(x < centerX + padx)  
      dir = QUAD_MIDDLE;
    else 
      dir = QUAD_RIGHT;

    if(y < centerY - pady)  
      dir |= QUAD_TOP;
    else if(y < centerY + pady)  
      dir |= QUAD_CENTER;
    else
      dir |= QUAD_BOTTOM;

    sizingDirection = dir;

  }


  
  private final boolean hasQuad(int quad) {
    return ((sizingDirection & quad) == quad);
  }


  
  private final Cursor getCursor() {

    
    if(hasQuad(QUAD_CENTER|QUAD_LEFT) || hasQuad(QUAD_CENTER|QUAD_RIGHT))
      return HZ_CURSOR;

    
    if(hasQuad(QUAD_MIDDLE|QUAD_TOP) || hasQuad(QUAD_MIDDLE|QUAD_BOTTOM))
      return VT_CURSOR;

    
    if(hasQuad(QUAD_BOTTOM|QUAD_LEFT) || hasQuad(QUAD_TOP|QUAD_RIGHT))
      return SWNE_CURSOR;

    return SENW_CURSOR;

  }

  
  final private Graphics2D getGraphics(Component c) {

    Graphics2D g = (Graphics2D)c.getGraphics();

    g.setColor(Color.gray);
    g.setXORMode(c.getBackground());
    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

    return g;

  }


  protected void reset() {

    if(diagram != null && originalCursor != null)
      diagram.setCursor(originalCursor);
    
    originalCursor = null;
    diagram = null;
    figure = null;
    graphics = null;
    lastPoint = dragPoint = null;

    java.util.Arrays.fill(relatedFigures, 0, relatedFigures.length, null);

  }

}
