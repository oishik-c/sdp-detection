Given the following java code, determine whether it contains an instance of the composite design pattern playing the role of composite.

You should read the entire code snippet carefully. Then answer with YES or NO in capital letters. Finally, In 2-3 short sentences, explain why that is the answer

CODE:


package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Enumeration;
import java.util.Vector;

import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.DrawingChangeEvent;
import CH.ifa.draw.framework.DrawingChangeListener;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureChangeEvent;
import CH.ifa.draw.framework.FigureEnumeration;



public class StandardDrawing extends CompositeFigure implements Drawing {


	
	private transient Vector              fListeners;

	
	private transient Thread    fDrawingLockHolder = null;

	
	private static final long serialVersionUID = -2602151437447962046L;
	private int drawingSerializedDataVersion = 1;

	
	public StandardDrawing() {
		super();
		fListeners = new Vector(2);
	}


	
	public void addDrawingChangeListener(DrawingChangeListener listener) {
		fListeners.addElement(listener);
	}

	
	public void removeDrawingChangeListener(DrawingChangeListener listener) {
		fListeners.removeElement(listener);
	}

	
	public Enumeration drawingChangeListeners() {
		return fListeners.elements();
	}

	

	public synchronized Figure remove(Figure figure) {
		
		if (figure.listener() != null) {
			figure.listener().figureRequestRemove(new FigureChangeEvent(figure, null));
			return figure;
		}
		return null;
	}


	
	public void figureRequestRemove(FigureChangeEvent e) {
		Figure figure = e.getFigure();
		if (fFigures.contains(figure)) {
			fFigures.removeElement(figure);
			figure.removeFromContainer(this);   
			figure.release();
		} else
			System.out.println("Attempt to remove non-existing figure");
	}

	
	public void figureInvalidated(FigureChangeEvent e) {
		if (fListeners != null) {
			for (int i = 0; i < fListeners.size(); i++) {
				DrawingChangeListener l = (DrawingChangeListener)fListeners.elementAt(i);
				l.drawingInvalidated(new DrawingChangeEvent(this, e.getInvalidatedRectangle()));
			}
		}
	}

	
	public void figureRequestUpdate(FigureChangeEvent e) {
		if (fListeners != null) {
			for (int i = 0; i < fListeners.size(); i++) {
				DrawingChangeListener l = (DrawingChangeListener)fListeners.elementAt(i);
				l.drawingRequestUpdate(new DrawingChangeEvent(this, null));
			}
		}
	}

	
	public Vector handles() {
		Vector handles = new Vector();
		handles.addElement(new NullHandle(this, RelativeLocator.northWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.northEast()));
		handles.addElement(new NullHandle(this, RelativeLocator.southWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.southEast()));
		return handles;
	}

	
	public Rectangle displayBox() {
		if (fFigures.size() > 0) {
			FigureEnumeration k = figures();

			Rectangle r = k.nextFigure().displayBox();

			while (k.hasMoreElements())
				r.add(k.nextFigure().displayBox());
			return r;
		}
		return new Rectangle(0, 0, 0, 0);
	}

	public void basicDisplayBox(Point p1, Point p2) {
	}

	
	public synchronized void lock() {
		
		Thread current = Thread.currentThread();
		if (fDrawingLockHolder == current)
			return;
		while (fDrawingLockHolder != null) {
			try { wait(); } catch (InterruptedException ex) { }
		}
		fDrawingLockHolder = current;
	}

	
	public synchronized void unlock() {
		if (fDrawingLockHolder != null) {
			fDrawingLockHolder = null;
			notifyAll();
		}
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		fListeners = new Vector(2);
	}
}
