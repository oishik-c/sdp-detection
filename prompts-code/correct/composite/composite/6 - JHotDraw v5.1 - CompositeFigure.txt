Given the following java code, determine whether it contains an instance of the composite design pattern playing the role of composite.

You should read the entire code snippet carefully. Then answer with YES or NO in capital letters. Finally, In 2-3 short sentences, explain why that is the answer

CODE:


package CH.ifa.draw.standard;

import CH.ifa.draw.util.*;
import CH.ifa.draw.framework.*;
import java.awt.*;
import java.util.*;
import java.io.*;



public abstract class CompositeFigure
				extends AbstractFigure
				implements FigureChangeListener {

	
	protected Vector fFigures;

	
	private static final long serialVersionUID = 7408153435700021866L;
	private int compositeFigureSerializedDataVersion = 1;

	protected CompositeFigure() {
		fFigures = new Vector();
	}

	
	public Figure add(Figure figure) {
		if (!fFigures.contains(figure)) {
			fFigures.addElement(figure);
			figure.addToContainer(this);
		}
		return figure;
	}

	
	public void addAll(Vector newFigures) {
		Enumeration k = newFigures.elements();
		while (k.hasMoreElements())
			add((Figure) k.nextElement());
	}

	
	public Figure remove(Figure figure) {
		if (fFigures.contains(figure)) {
			figure.removeFromContainer(this);
			fFigures.removeElement(figure);
		}
		return figure;
	}

	
	public void removeAll(Vector figures) {
		Enumeration k = figures.elements();
		while (k.hasMoreElements())
			remove((Figure) k.nextElement());
	}

	
	public void removeAll() {
		FigureEnumeration k = figures();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			figure.removeFromContainer(this);
		}
		fFigures.removeAllElements();
	}

	
	public synchronized Figure orphan(Figure figure) {
		fFigures.removeElement(figure);
		return figure;
	}

	
	public void orphanAll(Vector newFigures) {
		Enumeration k = newFigures.elements();
		while (k.hasMoreElements())
			orphan((Figure) k.nextElement());
	}

	
	public synchronized void replace(Figure figure, Figure replacement) {
		int index = fFigures.indexOf(figure);
		if (index != -1) {
			replacement.addToContainer(this);   
			figure.changed();
			fFigures.setElementAt(replacement, index);
		}
	}

	
	public synchronized void sendToBack(Figure figure) {
		if (fFigures.contains(figure)) {
			fFigures.removeElement(figure);
			fFigures.insertElementAt(figure,0);
			figure.changed();
		}
	}

	
	public synchronized void bringToFront(Figure figure) {
		if (fFigures.contains(figure)) {
			fFigures.removeElement(figure);
			fFigures.addElement(figure);
			figure.changed();
		}
	}

	
	public void draw(Graphics g) {
		FigureEnumeration k = figures();
		while (k.hasMoreElements())
			k.nextFigure().draw(g);
	}

	
	public Figure figureAt(int i) {
		return (Figure)fFigures.elementAt(i);
	}

	
	public final FigureEnumeration figures() {
		return new FigureEnumerator(fFigures);
	}

	
	public int figureCount() {
		return fFigures.size();
	}

	
	public final FigureEnumeration figuresReverse() {
		return new ReverseFigureEnumerator(fFigures);
	}

	
	public Figure findFigure(int x, int y) {
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			if (figure.containsPoint(x, y))
				return figure;
		}
		return null;
	}

	
	public Figure findFigure(Rectangle r) {
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			Rectangle fr = figure.displayBox();
			if (r.intersects(fr))
				return figure;
		}
		return null;
	}

	
	public Figure findFigureWithout(int x, int y, Figure without) {
		if (without == null)
			return findFigure(x, y);
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			if (figure.containsPoint(x, y) && !figure.includes(without))
				return figure;
		}
		return null;
	}

	
	public Figure findFigure(Rectangle r, Figure without) {
		if (without == null)
			return findFigure(r);
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			Rectangle fr = figure.displayBox();
			if (r.intersects(fr) && !figure.includes(without))
				return figure;
		}
		return null;
	}

	
	public Figure findFigureInside(int x, int y) {
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure().findFigureInside(x, y);
			if (figure != null)
				return figure;
		}
		return null;
	}

	
	public Figure findFigureInsideWithout(int x, int y, Figure without) {
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			if (figure != without) {
				Figure found = figure.findFigureInside(x, y);
				if (found != null)
					return found;
			}
		}
		return null;
	}

	
	public boolean includes(Figure figure) {
		if (super.includes(figure))
			return true;

		FigureEnumeration k = figures();
		while (k.hasMoreElements()) {
			Figure f = k.nextFigure();
			if (f.includes(figure))
				return true;
		}
		return false;
	}

	
	protected void basicMoveBy(int x, int y) {
		FigureEnumeration k = figures();
		while (k.hasMoreElements())
			k.nextFigure().moveBy(x,y);
	}

	
	public void release() {
		super.release();
		FigureEnumeration k = figures();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			figure.release();
		}
	}

	
	public void figureInvalidated(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureInvalidated(e);
	}

	
	public void figureRequestRemove(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureRequestRemove(new FigureChangeEvent(this));
	}

	
	public void figureRequestUpdate(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureRequestUpdate(e);
	}

	public void figureChanged(FigureChangeEvent e) {
	}

	public void figureRemoved(FigureChangeEvent e) {
	}

	
	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fFigures.size());
		Enumeration k = fFigures.elements();
		while (k.hasMoreElements())
			dw.writeStorable((Storable) k.nextElement());
	}

	
	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		int size = dr.readInt();
		fFigures = new Vector(size);
		for (int i=0; i<size; i++)
			add((Figure)dr.readStorable());
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		FigureEnumeration k = figures();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			figure.addToContainer(this);
		}
	}
}
