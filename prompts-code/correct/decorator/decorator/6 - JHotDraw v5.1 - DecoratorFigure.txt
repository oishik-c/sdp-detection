Given the following java code, determine whether it contains an instance of the decorator design pattern playing the role of decorator.

You should read the entire code snippet carefully. Then answer with YES or NO in capital letters. Finally, In 2-3 short sentences, explain why that is the answer

CODE:


package CH.ifa.draw.standard;

import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Vector;

import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureChangeEvent;
import CH.ifa.draw.framework.FigureChangeListener;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;



public abstract class DecoratorFigure
				extends AbstractFigure
				implements FigureChangeListener {

	
	protected Figure fComponent;

	
	private static final long serialVersionUID = 8993011151564573288L;
	private int decoratorFigureSerializedDataVersion = 1;

	public DecoratorFigure() { }

	
	public DecoratorFigure(Figure figure) {
		decorate(figure);
	}

	
	public Insets connectionInsets() {
		return fComponent.connectionInsets();
	}

	
	public boolean canConnect() {
		return fComponent.canConnect();
	}

	
	public boolean containsPoint(int x, int y) {
		return fComponent.containsPoint(x, y);
	}

	
	public void decorate(Figure figure) {
		fComponent = figure;
		fComponent.addToContainer(this);
	}

	
	public Figure peelDecoration() {
		fComponent.removeFromContainer(this); 
		return fComponent;
	}

	
	public Rectangle displayBox() {
		return fComponent.displayBox();
	}

	
	public void basicDisplayBox(Point origin, Point corner) {
		fComponent.basicDisplayBox(origin, corner);
	}

	
	public void draw(Graphics g) {
		fComponent.draw(g);
	}

	
	public Figure findFigureInside(int x, int y) {
		return fComponent.findFigureInside(x, y);
	}

	
	public Vector handles() {
		return fComponent.handles();
	}

	
	public boolean includes(Figure figure) {
		return (super.includes(figure) || fComponent.includes(figure));
	}

	
	public void moveBy(int x, int y) {
		fComponent.moveBy(x, y);
	}

	
	protected void basicMoveBy(int x, int y) {
		
	}

	
	public void release() {
		super.release();
		fComponent.removeFromContainer(this);
		fComponent.release();
	}

	
	public void figureInvalidated(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureInvalidated(e);
	}

	public void figureChanged(FigureChangeEvent e) {
	}

	public void figureRemoved(FigureChangeEvent e) {
	}

	
	public  void figureRequestUpdate(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureRequestUpdate(e);
	}

	
	public void figureRequestRemove(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureRequestRemove(new FigureChangeEvent(this));
	}

	
	public FigureEnumeration figures() {
		return fComponent.figures();
	}

	
	public FigureEnumeration decompose() {
		return fComponent.decompose();
	}

	
	public void setAttribute(String name, Object value) {
		fComponent.setAttribute(name, value);
	}

	
	public Object getAttribute(String name) {
		return fComponent.getAttribute(name);
	}

	
	public Locator connectedTextLocator(Figure text) {
		return fComponent.connectedTextLocator(text);
	}

	
	public Connector connectorAt(int x, int y) {
		return fComponent.connectorAt(x, y);
	}

	
	public void connectorVisibility(boolean isVisible) {
		fComponent.connectorVisibility(isVisible);
	}

	
	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeStorable(fComponent);
	}

	
	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		decorate((Figure)dr.readStorable());
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		fComponent.addToContainer(this);
	}
}
