Given the following java code, determine whether it contains an instance of the adapter design pattern playing the role of adapter.

You should read the entire code snippet carefully. Then answer with YES or NO in capital letters. Finally, In 2-3 short sentences, explain why that is the answer

CODE:


package org.openide.windows;

import java.awt.Image;
import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.Insets;
import java.awt.event.KeyEvent;
import java.util.*;
import java.beans.*;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.Externalizable;
import java.io.Serializable;
import java.io.IOException;
import java.io.ObjectStreamException;
import java.lang.reflect.Method;
import java.lang.ref.Reference;
import java.lang.ref.WeakReference;

import javax.swing.JComponent;
import javax.swing.undo.UndoableEdit;
import javax.swing.FocusManager;
import javax.swing.SwingUtilities;
import javax.swing.KeyStroke;

import org.openide.*;
import org.openide.awt.UndoRedo;
import org.openide.loaders.*;
import org.openide.actions.*;
import org.openide.util.actions.SystemAction;
import org.openide.nodes.*;
import org.openide.util.NbBundle;
import org.openide.util.WeakListener;
import org.openide.util.HelpCtx;


public class TopComponent extends JComponent implements Externalizable {
    
    static final long serialVersionUID = -3022538025284122942L;

    
    private static Registry registry;

    
    public static final int CLOSE_EACH = 0;
    
    public static final int CLOSE_LAST = 1;

    
    private static SystemAction[] systemActions;

    
    private NodeName nodeName;

    
    private WindowManager.Component manager;

    
    private int closeOperation = CLOSE_LAST;

    
    short serialVersion = 1;

    
    public TopComponent () {
        FocusMan.install();
        enableEvents (java.awt.AWTEvent.KEY_EVENT_MASK);

        
        
        setRequestFocusEnabled (false);
        
        
        
        getManager();
    }

    
    public TopComponent (DataObject obj) {
        this ();
        Node n = obj.getNodeDelegate ();

        nodeName = new NodeName (this);
        nodeName.attach (n);
    }

    
    public static final Registry getRegistry () {
        if (registry == null) {
            registry = TopManager.getDefault().getWindowManager().
                       componentRegistry();
        }
        return registry;
    }

    
    public final Node[] getActivatedNodes () {
        return getManager ().getActivatedNodes ();
    }

    
    public final void setActivatedNodes (Node[] nodes) {
        getManager ().setActivatedNodes (nodes);
        firePropertyChange ("activatedNodes", null, null); 
    }

    
    public UndoRedo getUndoRedo () {
        return UndoRedo.NONE;
    }

    
    public void open () {
        open(null);
    }

    
    public void open (Workspace workspace) {
        getManager().open(workspace);
    }

    
    public final boolean isOpened () {
        return getManager().whereOpened().size() > 0;
    }

    
    public final boolean isOpened (Workspace workspace) {
        return getManager().whereOpened().contains(workspace);
    }

    
    public final boolean close () {
        return close(
                   TopManager.getDefault().getWindowManager().getCurrentWorkspace()
               );
    }

    
    public final boolean close (Workspace workspace) {
        Set whereOpened = getManager().whereOpened();
        
        if ((closeOperation != CLOSE_EACH) && !whereOpened.contains(workspace))
            return true;
        boolean result = false;
        switch (closeOperation) {
        case CLOSE_LAST:
            result = canClose(workspace, whereOpened.size() == 1);
            break;
        case CLOSE_EACH:
            result = canClose(null, true);
            break;
        }
        if (result)
            getManager().close(workspace);
        return result;
    }


    
    public boolean canClose (Workspace workspace, boolean last) {
        return true;
    }

    
    
    

    
    public SystemAction[] getSystemActions () {
        
        if (systemActions == null)
            systemActions = new SystemAction[] {
                                SystemAction.get(SaveAction.class),
                                SystemAction.get(CloneViewAction.class),
                                null,
                                SystemAction.get(CloseViewAction.class)
                            };
        return systemActions;
    }

    
    public final void setCloseOperation (final int closeOperation) {
        if ((closeOperation != CLOSE_EACH) && (closeOperation != CLOSE_LAST))
            throw new IllegalArgumentException(
                NbBundle.getBundle(TopComponent.class).getString("EXC_UnknownOperation")
            );
        if (this.closeOperation == closeOperation) return;
        this.closeOperation = closeOperation;
        firePropertyChange ("closeOperation", null, null); 
    }

    
    public final int getCloseOperation () {
        return closeOperation;
    }

    
    protected void componentActivated () {
    }

    
    protected void componentDeactivated () {
    }

    
    
    
    
    
    

    
    public void requestFocus () {
        
        getManager().requestFocus();
        super.requestFocus();
    }

    
    public void setName (final String name) {
        if ((name != null) && (name.equals(getName())))
            return;
        
        super.setName(name);
        getManager().nameChanged();
    }

    
    public void setIcon (final Image icon) {
        getManager().setIcon(icon);
        firePropertyChange ("icon", null, null); 
    }

    
    public Image getIcon () {
        return getManager().getIcon();
    }

    
    
    
    
    

    
    public org.openide.util.HelpCtx getHelpCtx () {
        return new HelpCtx (TopComponent.class);
    }

    
    final WindowManager.Component getManager () {
        if (manager == null) {
            synchronized (this) {
                if (manager == null) {
                    manager = TopManager.getDefault ().getWindowManager ().createTopComponentManager (
                                  this
                              );
                }
            }
        }
        return manager;
    }

    
    public void writeExternal (ObjectOutput out)
    throws IOException {
        out.writeObject(new Short (serialVersion));

        out.writeInt (closeOperation);
        out.writeObject (getName());
        out.writeObject (getToolTipText());

        Node.Handle h = nodeName == null ? null : nodeName.node.getHandle ();
        out.writeObject(h);
    }

    
    public void readExternal (ObjectInput in)
    throws IOException, ClassNotFoundException {
        Object firstObject = in.readObject ();
        if (firstObject instanceof Integer) {
            
            serialVersion = 0;

            closeOperation = ((Integer)firstObject).intValue();
            DataObject obj = (DataObject)in.readObject();

            super.setName((String)in.readObject());
            setToolTipText((String)in.readObject());

            
            if (obj != null) {
                nodeName = new NodeName (this);
                nodeName.attach (obj.getNodeDelegate ());
            }
        } else {
            
            serialVersion = ((Short)firstObject).shortValue ();

            closeOperation = in.readInt ();
            super.setName ((String)in.readObject ());
            setToolTipText ((String)in.readObject ());

            Node.Handle h = (Node.Handle)in.readObject ();
            if (h != null) {
                Node n = h.getNode ();
                nodeName = new NodeName (this);
                nodeName.attach (n);
            }
        }
    }

    
    protected Object writeReplace () throws ObjectStreamException {
        return new Replacer(this);
    }

    
    public static interface Cloneable {
        
        public TopComponent cloneComponent ();
    }

    
    public static class NodeName extends NodeAdapter {
        
        private transient Reference top;
        
        private transient Node node;

        
        public NodeName (TopComponent top) {
            this.top = new WeakReference (top);
        }

        
        final void attach (Node n) {
            TopComponent top = (TopComponent)this.top.get ();
            if (top != null) {
                synchronized (top) {
                    
                    if (n == node) return;

                    
                    if (node != null) {
                        node.removeNodeListener (this);
                    }
                    node = n;

                    if (n != null) {
                        n.addNodeListener (this);
                        top.setActivatedNodes (new Node[] { n });
                        top.setName (n.getDisplayName ());
                    }
                }
            }
        }


        
        public void propertyChange(PropertyChangeEvent ev) {
            TopComponent top = (TopComponent)this.top.get ();
            if (top == null) {
                
                if (ev.getSource () instanceof Node) {
                    Node n = (Node)ev.getSource ();
                    n.removeNodeListener (this);
                }
                return;
            }

            
            attach (node);

            if (ev.getPropertyName ().equals (Node.PROP_DISPLAY_NAME)) {
                top.setName (node.getDisplayName());
            }
        }
    } 


    
    static class FocusMan extends FocusManager {
        
        private FocusManager delegate;

        
        private FocusMan (FocusManager d) {
            delegate = d;
        }

        
        public static void install () {
            FocusManager fm = getCurrentManager ();
            if (fm == null || fm.getClass () != FocusMan.class) {
                setCurrentManager (new FocusMan (fm));
            }
        }

        
        public void processKeyEvent(
            java.awt.Component focusedComponent,
            final java.awt.event.KeyEvent anEvent
        ) {
            if (ShortcutManager.isTransmodalAction (KeyStroke.getKeyStrokeForEvent (anEvent))) {
                
            } else {
                
                java.awt.Component c = focusedComponent;
                java.awt.Component mw = TopManager.getDefault ().getWindowManager ().getMainWindow ();

                java.awt.Window w = SwingUtilities.windowForComponent (c);
                if (w instanceof java.awt.Dialog) {
                    java.awt.Dialog d = (java.awt.Dialog)w;
                    if (d.isModal ()) {
                        return;
                    }
                }
            }
            
            
            delegate.processKeyEvent (focusedComponent, anEvent);
            
            if (!anEvent.isConsumed ()) {
                process (anEvent, focusedComponent);
            }
        }

        
        public void focusNextComponent(java.awt.Component aComponent) {
            delegate.focusNextComponent (aComponent);
        }

        
        public void focusPreviousComponent(java.awt.Component aComponent) {
            delegate.focusPreviousComponent (aComponent);
        }

        
        private static HashSet posted = new HashSet ();

        
        static void process (final KeyEvent ev, final java.awt.Component comp) {
            
            
            if (ev.getID () != KeyEvent.KEY_PRESSED || posted.contains (ev)) return;

            
            posted.add (ev);
            

            
            
            
            SwingUtilities.invokeLater (new Runnable () {
                                            public void run () {
                                                
                                                if (!ev.isConsumed ()) {
                                                    
                                                    KeyStroke key = KeyStroke.getKeyStrokeForEvent (ev);

                                                    java.awt.Component source = comp; 
                                                    
                                                    
                                                    
                                                    javax.swing.MenuElement[] menuitems =
                                                        javax.swing.MenuSelectionManager.defaultManager ().getSelectedPath ();
                                                    if (menuitems != null) {
                                                        for (int idx = menuitems.length - 1; idx >= 0; idx--) {
                                                            java.awt.Component menuitem = menuitems[idx].getComponent ();
                                                            if (! (menuitem instanceof javax.swing.JPopupMenu) &&
                                                                    (menuitem != null)) {
                                                                source = menuitem;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    
                                                    
                                                    java.awt.event.ActionEvent aev = new java.awt.event.ActionEvent
                                                                                     (source, java.awt.event.ActionEvent.ACTION_PERFORMED, org.openide.util.Utilities.keyToString (key));

                                                    if (ShortcutManager.processKeyStroke (key, aev)) {
                                                        ev.consume ();
                                                    }
                                                }
                                                posted.remove (ev);
                                            }
                                        });
        }
    }
    
    
    public static interface Registry {
        
        public static final String PROP_OPENED = "opened"; 
        
        public static final String PROP_ACTIVATED = "activated"; 
        
        public static final String PROP_CURRENT_NODES = "currentNodes"; 
        
        public static final String PROP_ACTIVATED_NODES = "activatedNodes"; 

        
        public Set getOpened ();

        
        public TopComponent getActivated ();

        
        public Node[] getCurrentNodes ();

        
        public Node[] getActivatedNodes ();

        
        public void addPropertyChangeListener (PropertyChangeListener l);

        
        public void removePropertyChangeListener (PropertyChangeListener l);
    }

    
    private static final class Replacer implements Serializable {
        
        static final long serialVersionUID=-8897067133215740572L;

        
        transient TopComponent tc;

        public Replacer (TopComponent tc) {
            this.tc = tc;
        }

        private void writeObject (ObjectOutputStream oos)
        throws IOException, ClassNotFoundException {
            
            oos.writeObject(tc.getClass().getName());
            
            tc.writeExternal(oos);
        }

        private void readObject (ObjectInputStream ois)
        throws IOException, ClassNotFoundException {
            
            
            String name = (String)ois.readObject();
            name = org.openide.util.Utilities.translate(name);
            try {
                Class tcClass = Class.forName(
                                    name,
                                    true,
                                    TopManager.getDefault().systemClassLoader()
                                );
                tc = (TopComponent)tcClass.newInstance();
                tc.readExternal(ois);
                
                Method resolveMethod = findReadResolveMethod(tcClass);
                if (resolveMethod != null) {
                    
                    Class[] result = resolveMethod.getExceptionTypes();
                    if ((result.length == 1) &&
                            ObjectStreamException.class.equals(result[0])) {
                        
                        if (Object.class.equals(resolveMethod.getReturnType())) {
                            
                            resolveMethod.setAccessible(true);
                            
                            try {
                                tc = (TopComponent)resolveMethod.invoke(tc, new Class[0]);
                            } finally {
                                resolveMethod.setAccessible(false);
                            }
                        }
                    }
                }
            } catch (Exception exc) {
                
                exc.printStackTrace();
                throw new IOException();
            }
        }

        
        private Object readResolve () throws ObjectStreamException {
            return tc;
        }

        
        private static Method findReadResolveMethod (Class clazz) {
            Method result = null;
            
            try {
                result = clazz.getMethod("readResolve", new Class[0]); 
            } catch (NoSuchMethodException exc) {
                
            }
            
            for (Class i = clazz; i != null; i = i.getSuperclass()) {
                try {
                    result = i.getDeclaredMethod("readResolve", new Class[0]); 
                    
                    break;
                } catch (NoSuchMethodException exc) {
                    
                }
            }
            return result;
        }

    } 

}


